# YoptaScript Grammar Overview

YoptaScript — экспериментальный язык со сленговым синтаксисом, который мы компилируем в современный ES2025 JavaScript. Этот документ фиксирует договорённости о том, какие лексемы и конструкции поддерживает язык. Формальная запись нужна, чтобы лексер, парсер и остальные фазы компилятора работали согласованно.

Ниже собраны правила для двух уровней анализа:
- **Лексический** — допустимые символы, ключевые слова, литералы, операторы.
- **Синтаксический** — из каких конструкций состоит программа и как они комбинируются.

## Character Set

- **Letters**: кириллица (`А-Я`, `а-я`, включая `ё`) и латиница (`A-Z`, `a-z`).
- **Digits**: `0-9`.
- **Separators**: пробел, табуляция, перевод строки (`\n`), возврат каретки (`\r`).
- **Punctuation**: ASCII-символы `(){}[],.;:` и спецсимволы `@#$%^&*!?`.
- **Comments**: строковые `# ...` и блочные `/* ... */` — лексер пропускает их.
- **Unicode**: любые прочие символы считаются ошибкой и должны порождать `Diagnostic`.

## Keyword Mapping (JS → YoptaScript)

| JavaScript | YoptaScript aliases |
|------------|---------------------|
| `break` | `харэ` |
| `case` | `лещ`, `аеслинайду` |
| `catch` | `гоп`, `аченетак`, `аченитак`, `ачёнетак` |
| `class` | `клёво`, `клево` |
| `const` | `ясенХуй`, `ЯсенХуй` |
| `continue` | `двигай` |
| `debugger` | `логопед` |
| `default` | `пахану`, `апохуй`, `наотыбись` |
| `delete` | `ёбнуть`, `ебнуть` |
| `do` | `крч` |
| `else` | `иливжопураз` |
| `enum` | `еээ`, `Еээ` |
| `export` | `предъява` |
| `extends` | `батя` |
| `finally` | `тюряжка` |
| `for` | `го` |
| `function` | `йопта` |
| `if` | `вилкойвглаз` |
| `import` | `спиздить` |
| `in` | `чоунастут` |
| `instanceof` | `шкура` |
| `new` | `гыйбать`, `захуярить` |
| `return` | `отвечаю` |
| `super` | `яга` |
| `switch` | `естьчо` |
| `this` | `тырыпыры` |
| `throw` | `пнх` |
| `try` | `хапнуть`, `побратски`, `пабрацки`, `пабратски` |
| `typeof` | `чезажижан` |
| `var` | `гыы` |
| `void` | `куку` |
| `while` | `потрещим` |
| `with` | `хзйопт` |

### Strict / Module Keywords

| JavaScript | YoptaScript aliases |
|------------|---------------------|
| `let` | `участковый` |
| `static` | `попонятия` |
| `yield` | `поебалу` |
| `await` | `сидетьНахуй` |
| `async` | `ассо` |
| `using` | `юзает` |

### Literals and Built-ins Treated as Keywords

| JavaScript | YoptaScript aliases |
|------------|---------------------|
| `null` | `нуллио`, `порожняк` |
| `true` | `трулио`, `чётко`, `четко`, `чотко` |
| `false` | `нетрулио`, `пиздишь`, `нечётко`, `нечетко`, `нечотко` |
| `undefined` | `неибу` |
| `NaN` | `нихуя` |

### Future Reserved Keywords

| JavaScript | YoptaScript aliases |
|------------|---------------------|
| `implements` | `силикон` |
| `interface` | `хуёво`, `хуево` |
| `package` | `клеёнка`, `клеенка` |
| `private` | `мой` |
| `protected` | `подкрыша` |
| `public` | `ебанное` |
| `arguments`* | `аргос` |
| `eval`* | `ебал` |

> *`arguments` и `eval` — специальные идентификаторы строгого режима; мы резервируем их, чтобы предотвращать ошибки времени выполнения.

### Дополнительные формы

- `function*` → `пиздюли` — объявление генератора.
- `yield*` → `поебалуна` — делегирование генератора.
- `of` → `сашаГрей` — используется в конструкции `for ... of`.

## Operators (ES2025 + Stage 3)

Лексер должен распознавать следующие комбинации символов как атомарные токены:

- Арифметика: `+`, `-`, `*`, `/`, `%`, `**`, `**=`.
- Присваивания: `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `**=`, `&&=`, `||=`, `??=`.
- Инкременты: `++`, `--`.
- Сравнения: `==`, `===`, `!=`, `!==`, `<`, `>`, `<=`, `>=`.
- Логика: `&&`, `||`, `??`, `!`.
- Опциональные цепочки: `?.`, `?.[]`, `?.()` (лексер должен выделять `?.`, `?.[` и `?.(` как отдельные токены).
- Nullish/optional присваивания: `??=`, `?.=` (если встретится).
- Pipeline: `|>`.
- Лямбды: `=>`.
- Decorator: `@`.
- Records & Tuples: `#{`, `#[`, а также закрывающие `}` и `]`.
- Деструктуризация: `...` (spread/rest оператор).
- Сравнение присваивания (stage 3): `:=`.
- Ресурсный менеджмент: `using` + потенциальная комбинация `await using`.

Для одиночных символов (`(`, `)`, `{`, `}`, `[`, `]`, `,`, `;`, `:`) лексер генерирует токены пунктуации. Для операторов с несколькими символами важно проверять максимально длинное совпадение (жадный матч), чтобы `??=` не распалось на `??` и `=`.

Эти инструкции задают полную «азбуку» для стадий ES2025 и всех Stage 3 предложений, которые могут попасть в стандарт.
